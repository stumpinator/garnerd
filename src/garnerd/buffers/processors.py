from typing import Callable, Optional, BinaryIO, Self, Iterator, Iterable
from pathlib import Path
from magic import from_buffer

from ..exceptions import SharedMemoryError

from . import SHMBufferSync, SharedMemoryError


class SHMProcessor:
    _buff_syncs: set[SHMBufferSync]
    bytes_processed: int
    reporting: dict
    
    def __init__(self, buff_syncs: Iterator[SHMBufferSync]):
        """base class for processing a file using shared memory and multiprocessing

        Args:
            buff_syncs (Iterator[SHMBufferSync]): sync objects to use.

        Raises:
            ValueError: no valid sync objects added
        """
        self._buff_syncs = set()
        for arg in buff_syncs:
            if isinstance(arg, SHMBufferSync):
                self._buff_syncs.add(arg)
        if len(self._buff_syncs) == 0:
            raise ValueError("No shared memory buffers")
        self.bytes_processed = 0
        self.reporting = None
    
    def cycle_syncs(self) -> Iterator[SHMBufferSync]:
        """Cycle through all sorted buffer sync objects indefinitely.

        Yields:
            Iterator[SHMBufferSync]: all buffer sync objects sorted by shared memory name. forever.
        """
        synclist = sorted(self._buff_syncs)
        x = 0
        m = len(synclist)
        while True:
            yield synclist[x]
            x += 1
            x %= m
    
    def load_buffers(self):
        """loads all shared memory objects in sync buffers

        Raises:
            SharedMemoryError: a buffer has size of 0
        """
        for buff in self._buff_syncs:
            buff.load_buffer()
            if buff.shmbuffer.size == 0:
                raise SharedMemoryError(f"Shared Memory Buffer {buff.shm_name} has size of 0")
    
    def report(self) -> dict:
        """
        Returns:
            dict: dictionary containing metdata generated by this processor
        """
        self.reporting['size'] = self.bytes_processed
        return self.reporting
    
    def handle_data(self, data: memoryview):
        """called by subclassed processors to handle the data pushed to the shared memory buffers

        Args:
            data (memoryview): chunk of data stream
        """
        pass
    
    def pre_process(self) -> bool:
        """Called before processing data stream in shared memory buffers

        Returns:
            bool: True if processing should continue
        """
        self.reporting = dict()
        self.bytes_processed = 0
        try:
            self.load_buffers()
        except SharedMemoryError:
            return False
        return True
    
    def post_process(self):
        """cleanup actions performed after processing
        """
        for buff in self._buff_syncs:
            buff.close()
    
    def process(self) -> dict:
        """Generates chunks of data passed through the shared memory buffers

        Returns:
            dict: report of metdata
        """
        if not self.pre_process():
            return {'error': 'pre_process failed'}
        
        bsiter = self.cycle_syncs()
        for bsync in bsiter:
            bsync.wait()
            buff = bsync.shmbuffer
            buff.load_size()
            datalen = len(buff)
            
            self.handle_data(buff.buf[:datalen])
            
            self.bytes_processed += datalen
            if datalen < buff.size or datalen == 0:
                break
        
        self.post_process()
        return self.report()


class FileMagicProcessor(SHMProcessor):
    mime: bool
    magic: bool
    
    def __init__(self, buff_syncs: Iterator[SHMBufferSync], magic: bool = True, mime: bool = True):
        """Generates magic file and mime metadata

        Args:
            buff_syncs (Iterator[SHMBufferSync]): sync objects to use.
            magic (bool, optional): store file magic in report. Defaults to True.
            mime (bool, optional): store mime in report. Defaults to True.
        """
        super().__init__(buff_syncs=buff_syncs)
        self.mime = mime
        self.magic = magic
    
    def handle_data(self, data: memoryview):
        if self.bytes_processed == 0:
            magicbytes = min(len(data), 8192)
            try:
                self.reporting['filemagic'] = from_buffer(data[:magicbytes].tobytes())
                self.reporting['filemime'] = from_buffer(data[:magicbytes].tobytes(), mime=True)
            except:
                pass


class FileWritingProcessor(SHMProcessor):
    file_path: str
    file_handle: BinaryIO|None
    
    def __init__(self, buff_syncs: Iterator[SHMBufferSync], file_path: str = None):
        """Saves the data to a file. Useful if data is being read from a socket.

        Args:
            buff_syncs (Iterator[SHMBufferSync]): sync objects to use.
            file_path (str, optional): path to save data. Defaults to None.

        Raises:
            ValueError: no file_path provided
        """
        if file_path is None:
            raise ValueError("No file_path supplied")
        super().__init__(buff_syncs=buff_syncs)
        self.file_path = file_path
    
    def pre_process(self) -> bool:
        try:
            self.file_handle = open(self.file_path, 'wb')
        except Exception as e:
            errs: list = self.reporting.setdefault('errors', list())
            errs.append(str(e))
            self.file_handle = None
        if not self.file_handle.writable():
            errs: list = self.reporting.setdefault('errors', list())
            errs.append(f"File {self.file_path} is not writable")
            self.file_handle.close()
            self.file_handle = None
        return super().pre_process()
    
    def handle_data(self, data):
        if self.file_handle is not None:
            self.file_handle.write(data)
            
    def post_process(self):
        if self.file_handle is not None:
            self.file_handle.close()
        super().post_process()


class FileReadingProcessor(SHMProcessor):
    file_path: str

    def __init__(self, buff_syncs: Iterator[SHMBufferSync], file_path: str = None):
        """Reads from file and pushes data to shared memory buffers.

        Args:
            buff_syncs (Iterator[SHMBufferSync]): sync objects to use.
            file_path (str, optional): file to read. Defaults to None.

        Raises:
            ValueError: invalid file_path
        """
        file_path = file_path or ''
        p = Path(file_path)
        if not p.exists() or not p.is_file():
            raise ValueError(f"{file_path} is not a valid file")
        super().__init__(buff_syncs=buff_syncs)
        self.file_path = file_path
    
    def process(self):
        if not self.pre_process():
            return {'error': 'pre_process failed'}
        
        bsiter = self.cycle_syncs()
        with open(self.file_path, 'rb', buffering=0) as f:
            for bsync in bsiter:
                buff = bsync.shmbuffer
                n = f.readinto(buff.buf) or 0
                self.bytes_processed += n
                buff.save_size(n)
                bsync.wait()
                if n < buff.size:
                    break
        
        self.post_process()
        return self.report()
    
